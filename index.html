<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Vôlei de Dupla</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f2f2f2;
      padding: 20px;
      text-align: center;
    }
    h1 { margin-bottom: 10px; }
    .team {
      margin: 20px 0;
    }
    .score {
      font-size: 2rem;
      margin: 10px 0;
    }
    .serving {
      color: green;
      font-weight: bold;
    }
    button, select, input[type="text"] {
      font-size: 1.1rem;
      margin: 5px;
      padding: 8px 15px;
    }
    .players-inputs {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 10px;
    }
    .players-inputs div {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #summary {
      margin-top: 30px;
      max-width: 400px;
      margin-left: auto;
      margin-right: auto;
      text-align: left;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
    }
    #historyLog {
      max-height: 150px;
      overflow-y: auto;
      font-size: 0.85rem;
      background: #eee;
      padding: 10px;
      border-radius: 5px;
      margin-top: 15px;
      white-space: pre-wrap;
      text-align: left;
    }
  </style>
</head>
<body>
  <h1>Placar - Vôlei de Dupla</h1>

  <div>
    <label for="tournamentPhase">Fase do Torneio:</label>
    <select id="tournamentPhase" onchange="changePhase()">
      <option value="Fase de Grupos">Fase de Grupos</option>
      <option value="Quartas de Final">Quartas de Final</option>
      <option value="Semifinal">Semifinal</option>
      <option value="Final">Final</option>
    </select>
  </div>

  <div id="set-info">Set 1</div>

  <div class="team">
    <h2>Time A</h2>
    <div class="players-inputs" id="teamA-inputs"></div>
    <div id="teamA-players"></div>
    <div class="score" id="scoreA">0</div>
    <button onclick="addPoint('A')">+ Ponto Time A</button>
  </div>

  <div class="team">
    <h2>Time B</h2>
    <div class="players-inputs" id="teamB-inputs"></div>
    <div id="teamB-players"></div>
    <div class="score" id="scoreB">0</div>
    <button onclick="addPoint('B')">+ Ponto Time B</button>
  </div>

  <div style="margin-top: 20px;">
    <button onclick="finishSet()">Finalizar Set</button>
    <button onclick="undo()">Desfazer último ponto</button>
  </div>

  <div style="margin-top: 20px;">
    <button onclick="exportGame()">Exportar jogo (JSON)</button>
    <input type="file" id="importFile" style="display:none" accept=".json" onchange="importGame(event)" />
    <button onclick="document.getElementById('importFile').click()">Importar jogo (JSON)</button>
  </div>

  <div id="summary"></div>

  <script>
    // Estado inicial dos jogadores
    let teamA = ["Ana", "Bia"];
    let teamB = ["Clara", "Duda"];

    // Histórico para undo
    const historyStack = [];

    // Estado do jogo
    let scoreA = 0;
    let scoreB = 0;
    let currentSet = 1;
    let sets = [];
    let server = { team: 'A', index: 0 };  // Quem está sacando
    let lastScoringTeam = null;
    let tournamentPhase = "Fase de Grupos";

    // --- Funções básicas ---

    function saveState() {
      const state = {
        teamA,
        teamB,
        scoreA,
        scoreB,
        currentSet,
        sets,
        server,
        lastScoringTeam,
        tournamentPhase,
        historyStack
      };
      localStorage.setItem('voleiState', JSON.stringify(state));
    }

    function loadState() {
      const saved = localStorage.getItem('voleiState');
      if (saved) {
        try {
          const state = JSON.parse(saved);
          teamA = state.teamA ?? ["Ana", "Bia"];
          teamB = state.teamB ?? ["Clara", "Duda"];
          scoreA = state.scoreA ?? 0;
          scoreB = state.scoreB ?? 0;
          currentSet = state.currentSet ?? 1;
          sets = state.sets ?? [];
          server = state.server ?? { team: 'A', index: 0 };
          lastScoringTeam = state.lastScoringTeam ?? null;
          tournamentPhase = state.tournamentPhase ?? "Fase de Grupos";
          // História não é restaurada para evitar inconsistência (pode ser mantida se quiser)
          // historyStack = state.historyStack ?? [];
          document.getElementById("tournamentPhase").value = tournamentPhase;
          document.getElementById("set-info").textContent = `Set ${currentSet}`;
        } catch {
          localStorage.removeItem('voleiState');
        }
      }
    }

    // Render dos jogadores com indicação do sacador
    function renderPlayers() {
      // Render time A
      const aHTML = teamA.map((name, i) =>
        (server.team === 'A' && server.index === i)
          ? `<div class="serving">➡️ ${name}</div>`
          : `<div>${name}</div>`
      ).join("");
      document.getElementById("teamA-players").innerHTML = aHTML;

      // Render time B
      const bHTML = teamB.map((name, i) =>
        (server.team === 'B' && server.index === i)
          ? `<div class="serving">➡️ ${name}</div>`
          : `<div>${name}</div>`
      ).join("");
      document.getElementById("teamB-players").innerHTML = bHTML;
    }

    // Render inputs para editar nomes
    function renderPlayerInputs() {
      const containerA = document.getElementById("teamA-inputs");
      const containerB = document.getElementById("teamB-inputs");

      containerA.innerHTML = "";
      containerB.innerHTML = "";

      teamA.forEach((name, i) => {
        const input = document.createElement("input");
        input.type = "text";
        input.value = name;
        input.size = 8;
        input.onchange = e => {
          teamA[i] = e.target.value.trim() || `Jogador A${i+1}`;
          saveState();
          renderPlayers();
          renderPlayerInputs();
        };
        containerA.appendChild(input);
      });

      teamB.forEach((name, i) => {
        const input = document.createElement("input");
        input.type = "text";
        input.value = name;
        input.size = 8;
        input.onchange = e => {
          teamB[i] = e.target.value.trim() || `Jogador B${i+1}`;
          saveState();
          renderPlayers();
          renderPlayerInputs();
        };
        containerB.appendChild(input);
      });
    }

    // Atualiza placar
    function updateScores() {
      document.getElementById("scoreA").textContent = scoreA;
      document.getElementById("scoreB").textContent = scoreB;
    }

    // Guarda estado atual no histórico para undo
    function pushHistory() {
      const snapshot = {
        scoreA,
        scoreB,
        currentSet,
        sets: JSON.parse(JSON.stringify(sets)), // cópia profunda
        server: { ...server },
        lastScoringTeam,
        tournamentPhase,
        teamA: [...teamA],
        teamB: [...teamB]
      };
      historyStack.push(snapshot);
      if(historyStack.length > 100) historyStack.shift(); // Limita histórico para 100 estados
    }

    // Função para adicionar ponto com lógica de saque segundo sua regra:
    // - Se time que pontua é o time que saca, o servidor NÃO muda (mesmo jogador)
    // - Se time que pontua é o adversário, o saque vai para o time adversário
    //   e servidor alterna entre jogador 0 e 1 dependendo do set e mudança
    // Porém conforme sua explicação detalhada:
    // Quando o time volta a sacar, alterna entre jogador 0 e 1, ou seja,
    // o saque não fica fixo sempre no jogador 0 do time adversário.
    // Para controlar isso, vamos manter um índice global de saques por time.
    // Para simplificar, vamos alternar o servidor do time que recupera saque
    // entre 0 e 1 a cada side-out.

    let lastServerIndexA = 0;
    let lastServerIndexB = 0;

    function addPoint(team) {
      pushHistory();

      if (team === 'A') scoreA++;
      else scoreB++;

      if (team === server.team) {
        // Time que está sacando pontuou: mantém servidor atual
      } else {
        // Side-out: muda time sacando, servidor alterna
        server.team = team;

        // Alterna servidor do time que passou a sacar
        if (team === 'A') {
          lastServerIndexA = 1 - lastServerIndexA;
          server.index = lastServerIndexA;
        } else {
          lastServerIndexB = 1 - lastServerIndexB;
          server.index = lastServerIndexB;
        }
      }

      lastScoringTeam = team;
      updateScores();
      renderPlayers();
      saveState();
    }

    // Finalizar set, reseta placares, incrementa set
    function finishSet() {
      pushHistory();

      sets.push({ set: currentSet, A: scoreA, B: scoreB });

      const resumo = sets.map(s =>
        `Set ${s.set}: ${s.A} x ${s.B}`
      ).join("<br>");

      document.getElementById("summary").innerHTML =
        `<h3>Súmula</h3><strong>Fase:</strong> ${tournamentPhase}<br>${resumo}`;

      currentSet++;
      scoreA = 0;
      scoreB = 0;

      // Mantém servidor do próximo set (como regra sua: começa no jogador 0)
      // e reseta alternância
      server.index = 0;
      if(server.team === 'A') lastServerIndexA = 0;
      else lastServerIndexB = 0;

      document.getElementById("set-info").textContent = `Set ${currentSet}`;
      updateScores();
      renderPlayers();
      saveState();
    }

    // Desfazer último ponto
    function undo() {
      if (historyStack.length === 0) {
        alert("Não há ações para desfazer.");
        return;
      }
      const prev = historyStack.pop();

      teamA = prev.teamA;
      teamB = prev.teamB;
      scoreA = prev.scoreA;
      scoreB = prev.scoreB;
      currentSet = prev.currentSet;
      sets = prev.sets;
      server = prev.server;
      lastScoringTeam = prev.lastScoringTeam;
      tournamentPhase = prev.tournamentPhase;

      document.getElementById("tournamentPhase").value = tournamentPhase;
      document.getElementById("set-info").textContent = `Set ${currentSet}`;
      updateScores();
      renderPlayers();
      renderPlayerInputs();
      saveState();
    }

    // Alterar fase do torneio
    function changePhase() {
      tournamentPhase = document.getElementById("tournamentPhase").value;
      saveState();
      renderSummary();
    }

    // Renderiza resumo (chamado depois de importar ou mudar fase)
    function renderSummary() {
      const resumo = sets.map(s =>
        `Set ${s.set}: ${s.A} x ${s.B}`
      ).join("<br>");

      document.getElementById("summary").innerHTML =
        `<h3>Súmula</h3><strong>Fase:</strong> ${tournamentPhase}<br>${resumo}`;
    }

    // Exportar estado atual como JSON
    function exportGame() {
      const exportData = {
        teamA,
        teamB,
        scoreA,
        scoreB,
        currentSet,
        sets,
        server,
        lastScoringTeam,
        tournamentPhase
      };
      const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `volei_dupla_${new Date().toISOString().slice(0,19).replace(/:/g,"-")}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    // Importar jogo JSON
    function importGame(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const data = JSON.parse(e.target.result);
          teamA = data.teamA || ["Ana", "Bia"];
          teamB = data.teamB || ["Clara", "Duda"];
          scoreA = data.scoreA ?? 0;
          scoreB = data.scoreB ?? 0;
          currentSet = data.currentSet ?? 1;
          sets = data.sets || [];
          server = data.server || { team: 'A', index: 0 };
          lastScoringTeam = data.lastScoringTeam || null;
          tournamentPhase = data.tournamentPhase || "Fase de Grupos";

          document.getElementById("tournamentPhase").value = tournamentPhase;
          document.getElementById("set-info").textContent = `Set ${currentSet}`;

          updateScores();
          renderPlayers();
          renderPlayerInputs();
          renderSummary();

          saveState();
          alert("Jogo importado com sucesso.");
        } catch {
          alert("Arquivo inválido.");
        }
      };
      reader.readAsText(file);
      // Limpa o input para poder importar mesmo arquivo novamente
      event.target.value = "";
    }

    // Inicialização
    loadState();
    renderPlayers();
    renderPlayerInputs();
    updateScores();
    renderSummary();
  </script>
</body>
</html>
